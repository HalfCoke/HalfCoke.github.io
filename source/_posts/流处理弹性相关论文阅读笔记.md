---
title: 流处理弹性相关论文阅读笔记
subtitle: 大数据流处理弹性伸缩
tags:
  - 论文阅读笔记
categories:
  - 论文阅读笔记
  - 流处理
  - 弹性
author:
  nick: HalfCoke
  link: 'https://halfcoke.github.io/'
typora-copy-images-to: upload
abbrlink: 575ad623
date: 2020-11-11 13:18:45
update: 2020-11-11 13:18:45
---

# 大数据流处理弹性伸缩论文阅读笔记

## [1] Multi-Level Elasticity for Data Stream Processing. IEEE Transactions on Parallel and Distributed Systems(TPDS).2019.A

### 研究内容

更改不同的执行容器(虚拟机、进程、线程)的数量来影响容器的性能。基本的想法是不同的执行容器会有不同的性能，但是也会带来不同的开销。作者的想法是自动提供最少的资源来满足应用所需的性能。在作者的方法中，使用低级别的容器组合来充分利用高级别容器的资源。

### 技术路线

多层次扩展的主要思路是，检查当前节点是否达到阈值，如果达到了就扩展节点，如果没达到就考虑增加一个进程。主要是在进行进程与虚拟机之间的调度。

文章中的应用程序主要考虑处理大量小信息的流处理程序(比如，推特消息，传感器日志)。文章提出了使用环境是非多租户环境，并且节点是应用专用(这个应该就是为了避免CPU等信息受干扰的问题)。算子实例之间平均分配数据流(不考虑数据倾斜)。

作者提出的方法依次执行以下步骤，（1）评估不同层次的执行容器的性能（2）为给定的负载提供适当的配置（3）构造具体应用的弹性控制器。

为了决定提供什么样的执行容器，需要知道不同级别的执行容器的并行度如何影响性能，作者获得这个信息的方式是通过平台提供，或进行基准测试。在考虑瓶颈算子的时候，是从离源算子近的地方开始考虑，避免上游影响下游。

#### 什么时候决定扩展

作者在考虑是否进行扩展时，是按照算子实例逐个考虑，通过比较实例的$Health$值是否低于$minHealth$来判断实例是否需要扩展。

#### 如何进行扩展

首先找到具有最小资源负载的节点(也就是当前空闲资源最多的节点)。当具有最多资源的节点的CPU与内存的占用超过设定的阈值，则会扩展起一个新的节点。如果节点还有资源，则会根据最优容器配置部署一个新的实例来提增加性能，这个最优信息是通过第一步中获得的。算法也会更新新的配置信息。

为了防止震荡发生，不是每次观察时都会进行缩放，而是对多个观察值进行线性回归来计算变化趋势。

### 结论

### 论文内容

#### 摘要

文章研究了在低延迟和最小资源使用情况下，以分析大量数据为目标的流处理环境的被动弹性问题。文章提出了一种弹性管理策略，该策略可以太藕节应用程序组件的并行度，同时明确解决执行容器的层次结构(虚拟机、进程、线程)。展示了错误提供执行容器所导致的性能衰减，并提出了一种方法来使用最少的资源增加性能。文章描述了监控指标并展示了如何考虑执行环境的细节。通过使用真实应用程序进行实验验证了方法的有效性。

#### Introduction

在不同的计算系统领域，大数据都是一个挑战。随着互连设备的普及，它出现在物联网中，随着高性能计算系统规模的增长而增长，并伴随着互联网和社交网络活动的扩展。也是数据只能的主要主题。

处理大数据有两种主要技术：批处理和流处理。批处理是先将数据存储在巨大的数据库中，然后再进行处理，通常使用可扩展的编程模型，例如Google的MapReduce。 但是，随着数据规模的不断增长，数据传输和存储的成本变得令人望而却步。

作者关注于执行环境，并研究如何更改不同执行容器的数量来影响程序的性能。

#### Motivation for Multi-level Elasticity

##### System Model

主要介绍了流处理模型，并引出多级并行实例及弹性等。

##### Preformance mertrics

在流处理环境下，主要的性能评价是应用程序处理输入负载并及时产生结果的能力。文章主要考虑单个算子实例的处理活动。提出以下指标：

- 元组接收数量：使用$received_T(c)$表示，量化实例$c$在时间$T$内所接收到的元组数量。
- 元组处理数量：$processed_T(c)$，量化实例$c$在时间$T$内所处理的元组数量。
- 处理活性：定义$health$指标，用来表示实例在时间$T$内所处理的元组与收到的元组的比例$health_T(c)=\frac{processed_T(c)}{received_T(c)}$。如果一个实例的$为$$health_T(c)=100\%$，则表示实例能够及时处理所有输入，相反，如果$health_T(c)<100\%$，则说明有些元组需要等待。如果这种情况持续，则这个实例则会变成应用的瓶颈。

应用程序能否满足具体的时间约束，依赖于多种因素，包括执行节点的可用资源、网络链接属性、输入负载的波动、应用程序的计算。文章中的应用程序主要考虑处理大量小信息的流处理程序(比如，推特消息，传感器日志)。这种应用程序的性能受限于计算资源的可用性，而不是网络。由于为应用程序配置的资源是分配给应用程序的执行容器的资源，因此在执行节点级别，它们受节点的内存和CPU容量的限制。因此监控如下资源：

- $CPU occupation$. 使用$totalCPU_T(n)$表示在给定执行节点$n$上在时间$T$内的平均$CPU$使用率。
- $Memory occupation$. 使用$totalMem_T(n)$表示在给定执行节点$n$上在时间$T$内的平均内存使用。

使用这两个指标可以跟踪节点的情况，如果这两个指标都没有饱和，则说明可以分配新的执行容器，否则，需要考虑扩展决定。

##### Preformances of Storm

- ![](https://gitee.com/halfcoke/blog_img/raw/master/img/20201111230437.png)

  这张图在更改任务并行度，1-4-4表示1个worker(进程)，4个executors(线程)，4个task，说明每个线程执行一个Task，1-4-16表示每个线程执行4个任务，1-4-64表示每个线程执行16个任务。三条线有着类似的表现，这说明只增加Task并行度对任务的性能没有影响。在Storm拓扑的实际使用中，任务的数量实际上定义了这个任务所用的最大的执行器(线程)的数量。

- ![image-20201111232803371](https://gitee.com/halfcoke/blog_img/raw/master/img/image-20201111232803371.png)

  线程级别的并行度变化能够改变性能，只要线程没有达到CPU核数限制。（实验环境是四核的机器）可以从b中看到，提升了线程数量后任务的出性能有提升，而当线程数量为8时，和4的表现基本一致。当CPU饱和时，health下降，当内存饱和时节点宕机。

- ![image-20201111231828781](https://gitee.com/halfcoke/blog_img/raw/master/img/image-20201111231828781.png)

  过量提供进程资源反而导致了性能下降，而且更多的进程导致了性能不稳定，这是因为多个进程占用更多的内存，导致了到达了节点的极限。

#### AStrategty ffor multi-level elasticity

文章提出了使用环境是非多租户环境，并且节点是应用专用(这个应该就是为了避免CPU等信息受干扰的问题)。算子实例之间平均分配数据流(不考虑数据倾斜)。

作者提出的方法依次执行以下步骤，（1）评估不同层次的执行容器的性能（2）为给定的负载提供适当的配置（3）构造具体应用的弹性控制器。

第一步解决了系统模型中的执行容器的层次结构，为了决定提供什么样的执行容器，需要知道不同级别的执行容器的并行度如何影响性能，作者获得这个信息的方式是通过平台提供，或进行基准测试。

在第二步中，作者自动测试应用程序，以建立给定级别的输入负载和合适应用程序配置之间的映射关系。这个想法是为了变化输入负载然后发现指定算子所需的并行度级别(相关的执行容器)。

测试程序如算法1所示，使用线性负载为应用程序提供输入。作者在考虑是否进行扩展时，是按照算子实例逐个考虑，通过比较实例的$Health$值是否低于$minHealth$来判断实例是否需要扩展。

![image-20201112110527246](https://gitee.com/halfcoke/blog_img/raw/master/img/image-20201112110527246.png)

扩展算法如算法2所示。首先找到具有最小资源负载的节点(也就是当前空闲资源最多的节点)。当具有最多资源的节点的CPU与内存的占用超过设定的阈值，则会扩展起一个新的节点。如果节点还有资源，则会根据最优容器配置部署一个新的实例来提增加性能，这个最优信息是通过第一步中获得的。算法也会更新新的配置信息。在进行向下扩展时，会尽快释放新分配的节点，主要目的是使用更少的节点。为了防止震荡发生，不是每次观察时都会进行缩放，而是对多个观察值进行线性回归来计算变化趋势。

![image-20201112111630936](https://gitee.com/halfcoke/blog_img/raw/master/img/image-20201112111630936.png)

#### Implementation

#### Experimental Evaluation

#### Related Work

#### Conclusion



